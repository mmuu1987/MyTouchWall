#pragma kernel CSPositionKernel
#pragma kernel InitLerp
#define thread_group_size_x 64
#define thread_group_size_y 1
#define P 3.141592653


#include "UnityCG.cginc"





struct FluidStruct
{
  float4 position;
  float3 velocity;
  float3 initialVelocity;
  float3 fluidUp;
  float3 fluidDown;
  float4 oldPos;
  float3 addvalUp;
  float3 addvalDown;
  int heardIndex;
  float4 originalPos;
  float4 freeMoveArg;
  int delayFrame;
};

RWStructuredBuffer<FluidStruct> positionBuffer;

RWTexture2D<half2> Velocity;

RWTexture2D<half2> VelocityTemp;

float _Dim;

float _DeltaTime;
float3 _Pos;//球体位置
float _Radius;//球体半径
float3 _Gravity;//重力
float _Threshold;//弹性系数
int _Column;
float Seed;

int ScreenWidth;
int ScreenHeight;


//视矩阵，也就是世界到摄像机的矩阵，由C#传递过来
float4x4 v;
//投影矩阵，也就是摄像机到屏幕的矩阵，由C#传递过来
float4x4 p;
//视矩阵的逆矩阵，也就是摄像机到世界的矩阵，由C#传递过来
float4x4 iv;
//投影矩阵的逆矩阵，也就是屏幕到摄像机的的矩阵，由C#传递过来
float4x4 ip;


//把世界坐标点转换到屏幕坐标，支持相机旋转
//ComputeScreenPos虽然为unityCG.cginc的方法，但是不涉及到矩阵，所以可以应用该方法
float2  WorldToScreenPos2(float3 pos)
{
  float4x4 vp = mul(p,v); 
  
  float4  vertex = mul(vp, float4(pos, 1.0));
  
  float4  screenPos = ComputeScreenPos(vertex);
  
  screenPos.xy=screenPos.xy/screenPos.w;
  
  float width = screenPos.x * ScreenWidth;
  
  float height = screenPos.y * ScreenHeight;
  
  return float2(width,height);
}

float rand(in float2 uv)
{
  float2 noise = (frac(sin(dot(uv ,float2(12.9898,78.233)*2.0)) * 43758.5453));
  return abs(noise.x + noise.y) * 0.5;
}

void rotate2D(inout float2 v, float r)
{
  float s, c;
  sincos(r, s, c);
  v = float2(v.x * c - v.y * s, v.x * s + v.y * c);
}
//x轴随机运动
float3 FreeMove(float4 freeMoveArg,float3 pos)
{
  float rangDow =step(0, pos.y -freeMoveArg.y);//算出底部位置是否已经超出自由运动范围

  float rangUp = step(0,   freeMoveArg.x - pos.y);//算出顶部位置是否已经超出自由运动范围

  float value1 = abs(pos.y-freeMoveArg.x) * rangDow * rangUp;

  value1 = (value1/(freeMoveArg.x-freeMoveArg.y)) *P/2;//转为弧度值，范围为[0,2π]

  value1 = sin(value1)*freeMoveArg.z * freeMoveArg.w;

  return  float3(value1,0,0);
}

//牵引移动，由头部牵动，其他部位不驱动
void TowMove(uint3 id)
{
  

  int index= positionBuffer[id.x].heardIndex;
  

  if(index>0)//证明是尾部索引该ID附带的信息是一条线尾部的quad的信息，移动将靠这个来带动
  {

    float4 pos = positionBuffer[index].position;

    float3 velocity = positionBuffer[index].velocity;

    float3  addvalUp = positionBuffer[index].addvalUp;

    float3 addvalDown =positionBuffer[index].addvalDown;

    float3 fluidUp = positionBuffer[index].fluidUp;

    float3 fluidDown = positionBuffer[index].fluidDown;

    float4 freeMoveArg = positionBuffer[index].freeMoveArg;

    float3 freemove = FreeMove(freeMoveArg,pos);

    positionBuffer[index].oldPos = pos;

    float2 screenPos = WorldToScreenPos2(pos);

    
    //从速度贴图上根据该点的位置获取速度
    half2 v = Velocity[int2(screenPos.x,_ScreenParams.y-screenPos.y)];

    VelocityTemp[int2(screenPos.x,_ScreenParams.y-screenPos.y)] = Velocity[screenPos];


    if(screenPos.y>_ScreenParams.y || screenPos.y<=0)
    {
      pos.xyz+=velocity;
    }
    else
    {
      pos.xy -= v*0.01 ;
    }
    
    
    
    positionBuffer[index].position = pos;

    positionBuffer[index].fluidUp = fluidUp;

    positionBuffer[index].addvalUp = addvalUp;

    positionBuffer[index].fluidDown = fluidDown;

    positionBuffer[index].addvalDown = addvalDown;


    [loop]
    for (int i = index+1; i <index + _Column; i++)//身体做移动运动
    {
      FluidStruct padTemp =  positionBuffer[i];

      if(padTemp.delayFrame>=0)//间隔多少帧运动，这里默认是0帧
      {
        padTemp.oldPos = padTemp.position;
        padTemp.delayFrame=0;
      }
      else
      {
        padTemp.delayFrame++;
      }
      padTemp.position = positionBuffer[i-1].oldPos;
      
      positionBuffer[i]=padTemp;
      
    }


    //随机取一个回复值
    float maxY = rand(float2(-pos.x*_DeltaTime,pos.x-Seed*_DeltaTime))*-10 -30;

    if(pos.y<=maxY)//证明线已经走出屏幕
    {
      //复位该线的所有组成物体
      float x = (rand(float2(-pos.x-Seed,pos.x-Seed*_DeltaTime))-0.5)*2 *18;
      [loop]
      for (int i = 0; i < _Column; i++)
      {
        // float4 opos = positionBuffer[index+i].originalPos;
        float4 opos = positionBuffer[index+i].originalPos;
        positionBuffer[index+i].position = float4(x,opos.y,opos.z,opos.w);
        positionBuffer[index+i].velocity =  positionBuffer[index+i].initialVelocity;

        positionBuffer[index+i].fluidUp = float3(0,0,0);
        positionBuffer[index+i].fluidDown = float3(0,0,0);
        positionBuffer[index].addvalDown =  float3(0,0,0);
        positionBuffer[index].addvalUp = float3(0,0,0);
      }
    }
    


  }
  
}

//自由迁移运动
void FreeMove(uint3 id : SV_DispatchThreadID)
{
    
  /*  if (id.x == 1)
    {
        positionBuffer[id.x].position.y = ScreenHeight;
        positionBuffer[id.x].position.x = ScreenWidth;
        return;
    }*/

    float4 pos = positionBuffer[id.x].position;

    float4 originalPos = positionBuffer[id.x].originalPos;

    float2 screenPos = WorldToScreenPos2(pos);

    //float4 originalPos = positionBuffer[0].position;

    float3 velocity = positionBuffer[0].velocity;
    
   
   
   
    //从速度贴图上根据该点的位置获取速度
    half2  v = Velocity[int2(screenPos.x, (ScreenHeight - screenPos.y))];
    pos.xy += v *4 ;

   // pos.xyz += velocity;
    
  //  float2 newScreenPos = WorldToScreenPos2(pos);

    if (screenPos.x >= ScreenWidth)
    {
        pos = originalPos;
    }
   

    positionBuffer[id.x].position = pos;
   
}

[numthreads(thread_group_size_x, thread_group_size_y, 1)]
void CSPositionKernel (uint3 id : SV_DispatchThreadID)
{

  

   FreeMove(id);
  
  
}

//位置变换  
[numthreads(thread_group_size_x, thread_group_size_y, 1)]
void InitLerp (uint3 id : SV_DispatchThreadID)
{

  
}