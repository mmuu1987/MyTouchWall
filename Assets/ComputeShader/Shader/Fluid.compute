#pragma kernel CSPositionKernel
#pragma kernel InitLerp
#define thread_group_size_x 64
#define thread_group_size_y 1
#define P 3.141592653


#include "UnityCG.cginc"





struct FluidStruct
{
  float4 position;
  float3 velocity;
  float3 initialVelocity;
  float3 fluidUp;
  float3 fluidDown;
  float4 oldPos;
  float3 addvalUp;
  float3 addvalDown;
  int heardIndex;
  float4 originalPos;
  float4 freeMoveArg;
  int delayFrame;
};

RWStructuredBuffer<FluidStruct> positionBuffer;

RWTexture2D<half2> Velocity;

float _Dim;

float _DeltaTime;
float3 _Pos;//球体位置
float _Radius;//球体半径
float3 _Gravity;//重力
float _Threshold;//弹性系数
int _Column;
float Seed;


//视矩阵，也就是世界到摄像机的矩阵，由C#传递过来
float4x4 v;
//投影矩阵，也就是摄像机到屏幕的矩阵，由C#传递过来
float4x4 p;
//视矩阵的逆矩阵，也就是摄像机到世界的矩阵，由C#传递过来
float4x4 iv;
//投影矩阵的逆矩阵，也就是屏幕到摄像机的的矩阵，由C#传递过来
float4x4 ip;


//把世界坐标点转换到屏幕坐标，支持相机旋转
//ComputeScreenPos虽然为unityCG.cginc的方法，但是不涉及到矩阵，所以可以应用该方法
float2  WorldToScreenPos2(float3 pos)
{
  float4x4 vp = mul(p,v); 
  
  float4  vertex = mul(vp, float4(pos, 1.0));
  
  float4  screenPos = ComputeScreenPos(vertex);
  
  screenPos.xy=screenPos.xy/screenPos.w;
  
  float width = screenPos.x * _ScreenParams.x;
  
  float height = screenPos.y * _ScreenParams.y;
  
  return float2(width,height);
}

float rand(in float2 uv)
{
  float2 noise = (frac(sin(dot(uv ,float2(12.9898,78.233)*2.0)) * 43758.5453));
  return abs(noise.x + noise.y) * 0.5;
}

void rotate2D(inout float2 v, float r)
{
  float s, c;
  sincos(r, s, c);
  v = float2(v.x * c - v.y * s, v.x * s + v.y * c);
}

//做自由落体运动
void DownMove(uint3 id)
{
  float4 pos = positionBuffer[id.x].position;

  float3 velocity = positionBuffer[id.x].velocity;

  velocity += _Gravity*_DeltaTime;

  pos.xyz += velocity*_DeltaTime;

  float d = distance(_Pos,pos.xyz);

  if(d<=_Radius)//撞上了
  {

    float3 dir = normalize( pos.xyz - _Pos);

    float3 value = dot(velocity, dir) * dir ;//弹力公式1

    velocity = (velocity - 2.0 * value * _Threshold);//弹力公式2 

    pos.xyz = _Pos + dir * _Radius;
  }

  positionBuffer[id.x].velocity = velocity;
  
  positionBuffer[id.x].position = pos;




  int index = positionBuffer[id.x].heardIndex;

  if(index>=0)//证明是线头
  {
    if(pos.y<=-30)//证明线已经走出屏幕
    {
      //复位该线的所有组成物体
      float x = (rand(float2(-pos.x,pos.x))-0.5)*2 *18;
      [loop]
      for (int i = 0; i < _Column; i++)
      {
        // float4 opos = positionBuffer[index+i].originalPos;
        positionBuffer[index-i].position = positionBuffer[index+i].originalPos;//float4(x,opos.y,opos.z,opos.w);
        positionBuffer[index-i].velocity = 0;
      }
    }
  }

}
//x轴随机运动
float3 FreeMove(float4 freeMoveArg,float3 pos)
{
  float rangDow =step(0, pos.y -freeMoveArg.y);//算出底部位置是否已经超出自由运动范围

  float rangUp = step(0,   freeMoveArg.x - pos.y);//算出顶部位置是否已经超出自由运动范围

  float value1 = abs(pos.y-freeMoveArg.x) * rangDow * rangUp;

  value1 = (value1/(freeMoveArg.x-freeMoveArg.y)) *P/2;//转为弧度值，范围为[0,2π]

  value1 = sin(value1)*freeMoveArg.z * freeMoveArg.w;

  return  float3(value1,0,0);
}

//牵引移动，由头部牵动，其他部位不驱动
void TowMove(uint3 id)
{
  

  int index= positionBuffer[id.x].heardIndex;
  

  if(index>0)//证明是尾部索引该ID附带的信息是一条线尾部的quad的信息，移动将靠这个来带动
  {

    float4 pos = positionBuffer[index].position;

    float3 velocity = positionBuffer[index].velocity;

    float3  addvalUp = positionBuffer[index].addvalUp;

    float3 addvalDown =positionBuffer[index].addvalDown;

    float3 fluidUp = positionBuffer[index].fluidUp;

    float3 fluidDown = positionBuffer[index].fluidDown;

    float4 freeMoveArg = positionBuffer[index].freeMoveArg;

    float3 freemove = FreeMove(freeMoveArg,pos);

    positionBuffer[index].oldPos = pos;
    
    pos.xyz+=velocity;
    
    
    positionBuffer[index].position = pos;

    positionBuffer[index].fluidUp = fluidUp;

    positionBuffer[index].addvalUp = addvalUp;

    positionBuffer[index].fluidDown = fluidDown;

    positionBuffer[index].addvalDown = addvalDown;


    [loop]
    for (int i = index+1; i <index + _Column; i++)//身体做移动运动
    {
      FluidStruct padTemp =  positionBuffer[i];

      if(padTemp.delayFrame>=0)//间隔多少帧运动，这里默认是0帧
      {
        padTemp.oldPos = padTemp.position;
        padTemp.delayFrame=0;
      }
      else
      {
        padTemp.delayFrame++;
      }
      padTemp.position = positionBuffer[i-1].oldPos;
      
      positionBuffer[i]=padTemp;
      
    }


    //随机取一个回复值
    float maxY = rand(float2(-pos.x*_DeltaTime,pos.x-Seed*_DeltaTime))*-10 -30;

    if(pos.y<=maxY)//证明线已经走出屏幕
    {
      //复位该线的所有组成物体
      float x = (rand(float2(-pos.x-Seed,pos.x-Seed*_DeltaTime))-0.5)*2 *18;
      [loop]
      for (int i = 0; i < _Column; i++)
      {
        // float4 opos = positionBuffer[index+i].originalPos;
        float4 opos = positionBuffer[index+i].originalPos;
        positionBuffer[index+i].position = float4(x,opos.y,opos.z,opos.w);
        positionBuffer[index+i].velocity =  positionBuffer[index+i].initialVelocity;

        positionBuffer[index+i].fluidUp = float3(0,0,0);
        positionBuffer[index+i].fluidDown = float3(0,0,0);
        positionBuffer[index].addvalDown =  float3(0,0,0);
        positionBuffer[index].addvalUp = float3(0,0,0);
      }
    }
    


  }
  
}

//自由迁移运动
void FreeMove(uint3 id)
{
  int index= positionBuffer[id.x].heardIndex;
  

  if(index>0)//证明是尾部索引该ID附带的信息是一条线尾部的quad的信息，移动将靠这个来带动
  {

    float4 pos = positionBuffer[index].position;

    float3 velocity = positionBuffer[index].velocity;

    float4 freeMoveArg = positionBuffer[index].freeMoveArg;

    positionBuffer[index].oldPos = pos;

    float3 freemove;

    float rangDow =step(0, pos.y -freeMoveArg.y);//算出底部位置是否已经超出自由运动范围

    float rangUp = step(0,   freeMoveArg.x - pos.y);//算出顶部位置是否已经超出自由运动范围

    

    float value1 = abs(pos.y-freeMoveArg.x) * rangDow * rangUp;

    value1 = (value1/(freeMoveArg.x-freeMoveArg.y)) *P/2;//转为弧度值，范围为[0,2π]

    value1 = sin(value1)*freeMoveArg.z * freeMoveArg.w;

    freemove = float3(value1,0,0);
    
    pos.xyz += (velocity+freemove)*_DeltaTime;
    
    positionBuffer[index].position = pos;



    [loop]
    for (int i = index+1; i <index + _Column; i++)//身体做移动运动
    {
      FluidStruct padTemp =  positionBuffer[i];

      if(padTemp.delayFrame>=0)//间隔多少帧运动，这里默认是0帧
      {
        padTemp.oldPos = padTemp.position;
        padTemp.delayFrame=0;
      }
      else
      {
        padTemp.delayFrame++;
      }
      padTemp.position = positionBuffer[i-1].oldPos;
      
      positionBuffer[i]=padTemp;
      
    }

    //随机取一个回复值
    float maxY = rand(float2(-pos.x*_DeltaTime,pos.x-Seed*_DeltaTime))*-10 -30;

    if(pos.y<=maxY)//证明线已经走出屏幕
    {
      //复位该线的所有组成物体
      
      float x = (rand(float2(-pos.x-Seed,pos.x-Seed*_DeltaTime))-0.5)*2 *18;

      [loop]
      for (int i = 0; i < _Column; i++)
      {
        float4 opos = positionBuffer[index+i].originalPos;
        positionBuffer[index+i].position = float4(x,opos.y,opos.z,opos.w);
        positionBuffer[index+i].velocity =  positionBuffer[index+i].initialVelocity;
      }
    }
    


  }
}

[numthreads(thread_group_size_x, thread_group_size_y, 1)]
void CSPositionKernel (uint3 id : SV_DispatchThreadID)
{

  // DownMove(id);
  
  TowMove(id);

  // FreeMove(id);
  
  
}

//位置变换  
[numthreads(thread_group_size_x, thread_group_size_y, 1)]
void InitLerp (uint3 id : SV_DispatchThreadID)
{

  
}